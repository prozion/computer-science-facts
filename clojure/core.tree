clojure.core
	list
	cons
	let
	loop
	fn
	first
	next
	rest
	conj
	second
	ffirst
	nfirst
	fnext
	nnext
	seq
	instance?
	seq?
	char?
	string?
	map?
	vector?
	assoc
	meta
	with-meta
	assert-valid-fdecl
	sigs
	last
	butlast
	defn
	to-array
	cast
	vector
	vec
	hash-map
	hash-set
	sorted-map
	sorted-map-by
	sorted-set
	sorted-set-by
	nil?
	defmacro
	when
	when-not
	false?
	true?
	boolean?
	not
	some?
	any?
	str
	symbol?
	keyword?
	cond
	symbol
	gensym
	keyword
	find-keyword
	spread
	list*
	apply
	vary-meta
	lazy-seq
	chunk-buffer
	chunk-append
	chunk
	chunk-first
	chunk-rest
	chunk-next
	chunk-cons
	chunked-seq?
	concat
	delay
	delay?
	force
	if-not
	identical?
	=
	not=
	compare
	and
	or
	zero?
	count
	int
	nth
	<
	inc'
	inc
	reduce1
	reverse
	complement
	constantly
	identity
	name
	namespace
	boolean
	ident?
	simple-ident?
	qualified-ident?
	simple-symbol?
	qualified-symbol?
	locking
	..
	-> ; second item
	->> ; last item
	check-valid-options
	print-method
	print-dup
	pr-on
	pr
	system-newline
	newline
	flush
	prn
	print
	println
	read
	read+string
	read-line
	read-string
	subvec
	with-open
	doto
	memfn
	time
	macroexpand-1
	macroexpand
	create-struct
	defstruct
	struct-map
	struct
	accessor
	load-reader
	load-string
	set?
	set
	filter-key
	find-ns
	create-ns
	remove-ns
	all-ns
	the-ns
	ns-name
	ns-map
	ns-unmap
	ns-publics
	ns-imports
	ns-interns
	refer
	ns-refers
	alias
	ns-aliases
	ns-unalias
	take-nth
	interleave
	var-get
	var-set
	with-local-vars
	ns-resolve
	resolve
	array-map
	seq-to-map-for-destructuring
	destructure
	let
	maybe-destructured
	fn
	loop
	when-first
	lazy-cat
	for
	comment
	with-out-str
	with-in-str
	pr-str
	prn-str
	print-str
	println-str
	elide-top-frames
	ex-info
	ex-data
	ex-message
	ex-cause
	assert
	test
	re-pattern
	re-matcher
	re-groups
	re-seq
	re-matches
	re-find
	rand
	rand-int
	defn-
	tree-seq
	file-seq
	xml-seq
	special-symbol?
	var?
	subs
	max-key
	min-key
	distinct
	replace
	dosync
	with-precision
	mk-bound-fn private:<t>
	subseq
	rsubseq
	repeatedly
	add-classpath
	hash
	mix-collection-hash
	hash-ordered-coll
	hash-unordered-coll
	interpose
	definline
	empty
	amap
	areduce
	float-array
	boolean-array
	byte-array
	char-array
	short-array
	double-array
	object-array
	int-array
	long-array
	booleans
	bytes
	chars
	shorts
	floats
	ints
	doubles
	longs
	bytes?
	seque
	class?
	is-annotation?
	is-runtime-annotation?
	descriptor
	add-annotation
	process-annotation
	add-annotations
	alter-var-root
	bound?
	thread-bound?
	make-hierarchy
	not-empty
	bases
	supers
	isa?
	parents
	ancestors
	descendants
	derive
	underive
	distinct?
	resultset-seq
	iterator-seq
	enumeraton-seq
	format
	printf
	with-loading-context
	ns
	refer-clojure
	defonce
	empty?
	coll?
	list?
	seqable?
	ifn?
	fn?
	associative?
	sequential?
	sorted?
	counted?
	reversible?
	indexed?
	*1
	*2
	*3
	*e
	trampoline
	intern
	while
	memoize
	condp
	future?
	future-done?
	letfn
	fnil
	zipmap
	inst-ms
	inst?
	uuid?
	reduce
	reduce-kv
	completing
	transduce
	into
	mapv
	filterv
	normalize-slurp-opts private:<t>
	slurp
	spit
	clojure-version
	promise
	deliver
	flatten
	group-by
	partition-by
	reductions
	rand-nth
	partition-all
	shuffle
	map-indexed
	keep
	keep-indexed
	bounded-count
	every-pred
	some-fn
	assert-valid-fdecl private:<t>
	with-redefs-fn
	with-redefs
	realized?
	cond->
	cond->>
	as->
	some->
	some->>
	preserving-reduced private:<t>
	cat
	halt-when
	dedupe
	random-sample
	Eduction
	eduction
	run!
	tagged-literal?
	tagged-literal
	reader-conditional?
	reader-conditional
	*default-data-reader-fn*
	data-reader-urls
	data-reader-var
	load-data-reader-file
	load-data-readers
	uri?
	tapset
	tapq
	tap-loop
	add-tap
	remove-tap
	tap>
	update-vals
	update-keys
	math_stuff	
		nary-inline
		>1?
		>0?
		+'
		+
		*'
		*
		/
		-'
		-
		<=
		>
		>=
		==
		max
		min
		dec'
		dec
		unchecked-inc-int
		unchecked-dec
		unchecked-negate-int
		unchecked-negate
		unchecked-add-int
		unchecked-add
		unchecked-subtract-int
		unchecked-subtract
		unchecked-multiply-int
		unchecked-multiply
		unchecked-divide-int
		unchecked-remainder-int
		pos?
		neg?
		quot
		rem
		rationalize
		integer?
		even?
		odd?
		int?
		pos-int?
		neg-int?
		nat-int?
		double?
		bit_operations	
			bit-not
			bit-and
			bit-or
			bit-xor
			bit-and-not
			bit-clear
			bit-set
			bit-flip
			bit-test
			bit-shift-left
			bit-shift-right
			unsigned-bit-shift-right
	list_stuff	
		peek
		pop
	map_stuff	
		map-entry?
		contains?
		get
		dissoc
		disj
		find
		select-keys
		keys
		vals
		key
		val
		rseq
	multimethods	
		defmulti
		defmethod
		remove-all-methods
		remove-method
		prefer-method
		methods
		get-method
		prefers
	var_stuff	
		assert-args
		if-let
		when-let
		if-some
		when-some
		pusj-thread-bindings
		pop-thread-bindings
		get-thread-bindings
		binding
		with-bindings*
		with-bindings
		bound-fn*
		bound-fn
		find-var
		binding-conveyor-fn
	refs	
		setup-reference
		agent
		set-agent-send-executor!
		set-agent-send-off-executor!
		send-via
		send
		send-off
		relese-pending-sends
		add-watch
		remove-watch
		agent-error
		restart-agent
		set-error-handler!
		error-handler
		set-error-mode!
		error-mode
		agent-errors
		clear-agent-errors
		shutdown-agents
		ref
		deref-future
		deref
		atom
		swap!
		swap-vals!
		compare-and-set!
		reset!
		reset-vals!
		set-validator!
		get-validator
		alter-meta!
		reset-meta!
		commute
		alter
		ref-set
		ref-history-count
		ref-min-history
		ref-max-history
		ensure
		sync
		io!
		volatile!
		vreset!
		vswap!
		volatile?
	fn_stuff	
		comp
		juxt
		partial
		sequence
		every?
		not-every?
		some?
		not-any?
		dotimes
		map
		declare
		mapcat
		filter
		remove
		reduced
		reduced?
		ensure-reduced
		unreduced
		take
		take-while
		drop
		drop-last
		take-last
		drop-while
		cycle
		split-at
		split-with
		repeat
		replicate
		iterate
		range
		merge
		merge-with
		line-seq
		comparator
		sort
		sort-by
		dorun
		doall
		nthnext
		nthrest
		partition
	evaluation	
		eval
		doseq
		await
		await1
		await-for
		dotimes
		into
	editable_collections	
		transient
		persistent!
		conj!
		assoc!
		dissoc!
		pop!
		disj!
	redef_into_with_batch_support	
		into1
		import
		into-array
		array
		class
		type
		num
		long
		float
		double
		short
		byte
		char
		unchecked-byte
		unchecked-short
		unchecked-char
		unchecked-int
		unchecked-long
		unchecked-float
		unchecked-double
		number?
		mod
		ratio?
		numerator
		denominator
		decimal?
		float?
		rational?
		bigint
		biginteger
		bigdec
	arrays	
		alength
		aclone
		aget
		aset
		def-aset
		aset-int
		aset-long
		aset-boolean
		aset-float
		aset-double
		aset-short
		aset-byte
		aset-char
		make-array
		to-array-2d
	require/use/load +private:<t>	
		*loaded-libs*
		*pending-paths*
		*loading-verbosely*
		throw-if
		libspec?
		prependss
		root-resource
		root-directory
		load-one
		load-all
		load-lib
		load-libs
		check-cyclic-dependency
		require
		serialized-require
		requiring-resolve private:<f>
		use private:<f>
		loaded-libs private:<f>
		load private:<f>
		compile private:<f>
	nested_associative_ops	
		get-in
		assoc-in
		update-in
		update
	var_documentation	
		add-doc-and-meta
		*file*
		*command-line-args*
		*warn-on-reflection*
		*compile-path*
		*compile-files*
		*unchecked-math*
		*compiler-options*
		*ns*
		*in*
		*out*
		*err*
		*flush-on-newline*
		*print-meta*
		*print-dup*
		*print-readably*
		*read-eval*
	case +private:<t>		
		shift-mask
		maybe-min-hash
		case-map
		fits-table?
		prep-ints
		merge-hash-collisions
		prep-hashes
		case private:<f>
	futures	
		future-call
		future
		future-cancel
		future-cancelled?
		pmap
		pcalls
		pvalues
		
		
		
		
		
		
		
		
	